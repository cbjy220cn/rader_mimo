
╔════════════════════════════════════════════════════════════════╗
║     复杂运动轨迹补充实验 - 稀疏阵列孔径填充验证              ║
╚════════════════════════════════════════════════════════════════╝

输出目录: validation_results\complex_trajectory_test_20260103_202459

【雷达系统参数】
  载频: 3.00 GHz (λ = 9.99 cm)
  带宽: 50 MHz, 距离分辨率: 3.0 m

【阵列参数】
  正常间距: 5.00 cm (0.50λ)
  稀疏间距: 19.99 cm (2.00λ) ← 存在栅瓣风险

【实验参数】
  目标: φ=30°, θ=75°, R=500m
  观测时间: 0.5s, 快拍数: 64
  SNR范围: [-10, 20]dB, 试验次数: 30

【搜索配置】
  搜索模式: 2D DOA
  智能搜索: 启用 (四层搜索，最终精度0.01°)

【稀疏阵列定义】- 重点验证孔径填充效果
  1. 稀疏ULA-4: 4元稀疏线阵(2λ间距) (4阵元) ⚠栅瓣
  2. 稀疏圆阵-4: 4元稀疏圆阵(1.5λ半径) (4阵元) ⚠栅瓣
  3. 稀疏十字-5: 稀疏十字阵(2λ间距) (5阵元) ⚠栅瓣
  4. ULA-8(基准): 8元标准线阵(0.5λ) (8阵元)
  5. 稀疏L阵列: L形稀疏阵(2λ间距) (5阵元) ⚠栅瓣

【复杂运动模式定义】
  1. 静态: 无运动基准
  2. 螺旋上升: 圆周+上升
  3. 8字形: Lissajous曲线
  4. 圆弧平移: 半圆+直线
  5. 对角平移: xy同向平移
  6. 螺旋波动: 双周螺旋+z波动

═══════════════════════════════════════════════════════════════════
开始实验 (5阵列 × 6运动 × 7SNR × 30试验)
═══════════════════════════════════════════════════════════════════

[1/30] 稀疏ULA-4 + 静态: 孔径=3.0λ(x:3.0,y:0.0,z:0.0), 主瓣=0.1°, 填充=0.33, 方法=静态
[2/30] 稀疏ULA-4 + 螺旋上升: 孔径=11.1λ(x:9.0,y:6.0,z:2.5), 主瓣=N/A, 填充=0.03, 方法=自适应
[3/30] 稀疏ULA-4 + 8字形: 孔径=36.7λ(x:33.0,y:16.0,z:0.0), 主瓣=4.7°, 填充=0.03, 方法=自适应
[4/30] 稀疏ULA-4 + 圆弧平移: 孔径=28.2λ(x:13.0,y:25.0,z:0.0), 主瓣=N/A, 填充=0.05, 方法=标准
[5/30] 稀疏ULA-4 + 对角平移: 孔径=37.6λ(x:28.0,y:25.0,z:0.0), 主瓣=0.3°, 填充=0.02, 方法=标准
[6/30] 稀疏ULA-4 + 螺旋波动: 孔径=12.4λ(x:9.0,y:6.0,z:6.0), 主瓣=9.2°, 填充=0.01, 方法=自适应
[7/30] 稀疏圆阵-4 + 静态: 孔径=2.1λ(x:1.5,y:1.5,z:0.0), 主瓣=0.1°, 填充=0.11, 方法=静态
[8/30] 稀疏圆阵-4 + 螺旋上升: {操作在以下过程中被用户终止 <a href="matlab:matlab.lang.internal.introspective.errorDocCallback('DoaEstimatorSynthetic/estimate', 'E:\code\matlab\rader_mimo\scripts\asset\DoaEstimatorSynthetic.m', 318)" style="font-weight:bold">DoaEstimatorSynthetic/estimate</a> (<a href="matlab: opentoline('E:\code\matlab\rader_mimo\scripts\asset\DoaEstimatorSynthetic.m',318,0)">第 318 行</a>)


位置 <a href="matlab:matlab.lang.internal.introspective.errorDocCallback('complex_trajectory_test>smart_search_2d_synthetic', 'E:\code\matlab\rader_mimo\scripts\complex_trajectory_test.m', 1022)" style="font-weight:bold">complex_trajectory_test>smart_search_2d_synthetic</a> (<a href="matlab: opentoline('E:\code\matlab\rader_mimo\scripts\complex_trajectory_test.m',1022,0)">第 1022 行</a>)
    [~, peaks_fine, ~] = estimator.estimate(snapshots, t_axis, grid_fine, num_targets, est_options);
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
位置 <a href="matlab:matlab.lang.internal.introspective.errorDocCallback('complex_trajectory_test', 'E:\code\matlab\rader_mimo\scripts\complex_trajectory_test.m', 363)" style="font-weight:bold">complex_trajectory_test</a> (<a href="matlab: opentoline('E:\code\matlab\rader_mimo\scripts\complex_trajectory_test.m',363,0)">第 363 行</a>)
                        [est_theta, est_phi] = smart_search_2d_synthetic(estimator, snapshots, t_axis, smart_2d, 1, est_options);
                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
} 
debug_beamwidth
【静态】
  谱最大值: 1.98e+03, 平均值: 2.95e+01, 比值: 67.0
  估计角度: φ=30.2°, θ=75.3°
  峰值位置: phi_idx=103 (范围1-201)
  3dB点: left=102, right=104
  3dB宽度: 0.2°

【X平移】
  谱最大值: 1.02e+01, 平均值: 7.48e-01, 比值: 13.6
  估计角度: φ=28.2°, θ=72.0°
  峰值位置: phi_idx=83 (范围1-201)
  3dB点: left=77, right=88
  3dB宽度: 1.1°

【螺旋】
  谱最大值: 1.71e+01, 平均值: 1.02e+01, 比值: 1.7
  估计角度: φ=29.6°, θ=73.9°
  峰值位置: phi_idx=97 (范围1-201)
  3dB点: left=30, right=154
  3dB宽度: 12.4°

【8字形】
  谱最大值: 1.72e+01, 平均值: 5.81e+00, 比值: 3.0
  估计角度: φ=30.2°, θ=75.2°
  峰值位置: phi_idx=103 (范围1-201)
  3dB点: left=69, right=132
  3dB宽度: 6.3°

debug_beamwidth
【静态】
  谱最大值: 1.98e+03, 平均值: 2.95e+01, 比值: 67.0
  估计角度: φ=30.2°, θ=75.3°
  峰值位置: phi_idx=103 (范围1-201)
  3dB点: left=102, right=104
  3dB宽度: 0.2°

【X平移】
  谱最大值: 1.02e+01, 平均值: 7.48e-01, 比值: 13.6
  估计角度: φ=28.2°, θ=72.0°
  峰值位置: phi_idx=83 (范围1-201)
  3dB点: left=77, right=88
  3dB宽度: 1.1°

【螺旋】
  谱最大值: 1.05e+02, 平均值: 2.01e+01, 比值: 5.2
  估计角度: φ=27.2°, θ=70.0°
  峰值位置: phi_idx=73 (范围1-201)
  3dB点: left=54, right=91
  3dB宽度: 3.7°

【8字形】
  谱最大值: 9.61e+01, 平均值: 8.16e+00, 比值: 11.8
  估计角度: φ=30.1°, θ=76.0°
  峰值位置: phi_idx=102 (范围1-201)
  3dB点: left=94, right=110
  3dB宽度: 1.6°

debug_basic_synthetic
═══════════════════════════════════════════════════════════════════
         最基本的合成孔径原理验证                                  
═══════════════════════════════════════════════════════════════════

【参数】
  波长: 10.00 cm
  物理阵元: 4
  快拍数: 16
  运动速度: 5.0 m/s
  观测时间: 0.50 s
  运动距离: 2.50 m = 25.0 λ
  目标角度: φ=60.0°

【信号生成】
  AR(1)相关系数: 0.95
  信号幅度: |s| = [1.00, 1.15, ... , 1.15]
  信号相位: ∠s = [-148.7°, -135.6°, ... , 111.4°]

【接收信号生成】
  信号矩阵大小: 4 × 16

═══════════════════════════════════════════════════════════════════
方法1: 静态MUSIC（忽略运动）
═══════════════════════════════════════════════════════════════════
  特征值: [5.07, 0.01, 0.01, 0.01]
  估计角度: 120.00°（真实: 60.0°）
  误差: 60.00°

═══════════════════════════════════════════════════════════════════
方法2: 全虚拟阵列（直接展开）
═══════════════════════════════════════════════════════════════════
  虚拟阵元数: 64
  虚拟孔径: 2.65 m = 26.5 λ
  协方差矩阵大小: 64 × 64
  协方差矩阵秩: 1（应该是1）
  ⚠ 秩-1问题: 不能直接用MUSIC
  波束形成估计: 59.50°（误差: 0.50°）

═══════════════════════════════════════════════════════════════════
方法3: 时间平滑MUSIC
═══════════════════════════════════════════════════════════════════
  子阵列快拍数: 4
  子阵列数: 13
  子阵列大小: 16
  平滑协方差矩阵秩: 13
  特征值(前5): [19.77, 0.57, 0.28, 0.06, 0.03]
  子阵列孔径: 0.65 m = 6.5 λ
  估计角度: 59.50°（真实: 60.0°）
  误差: 0.50°

═══════════════════════════════════════════════════════════════════
                          总结                                     
═══════════════════════════════════════════════════════════════════

方法            | 孔径     | 误差    | 说明
----------------|----------|---------|---------------------------
静态MUSIC       | 1.5λ   | 60.00°  | 忽略运动，用t=0位置
全虚拟波束形成   | 26.5λ   | 0.50°  | 秩-1，只能用波束形成
时间平滑MUSIC   | 6.5λ   | 0.50°  | 空间平滑的时间版本

测试完成！
debug_time_smoothing_tradeoff
═══════════════════════════════════════════════════════════════════
                 时间平滑MUSIC 孔径-秩 折中分析                    
═══════════════════════════════════════════════════════════════════
【基本参数】
  波长: 10.00 cm
  物理阵元: 4
  物理孔径: 1.5λ
  快拍数: 32
  运动距离: 2.50 m = 25.0λ
  全虚拟孔径: 26.5λ

═══════════════════════════════════════════════════════════════════
              不同子阵列快拍数的性能对比                           
═══════════════════════════════════════════════════════════════════
子阵列快拍 | 子阵列大小 | 子阵列数 | 子阵列孔径 | 秩  | 估计角度 | 误差
-----------|------------|----------|------------|-----|----------|------
     2     |      8     |    31    |     2.3λ   |   8 |  103.0°  | 43.0°
     4     |     16     |    29    |     3.9λ   |  16 |  105.5°  | 45.5°
     8     |     32     |    25    |     7.1λ   |  25 |  100.0°  | 40.0°
    12     |     48     |    21    |    10.4λ   |  21 |   33.0°  | 27.0°
    16     |     64     |    17    |    13.6λ   |  17 |  158.0°  | 82.0°
    24     |     96     |     9    |    20.0λ   |   9 |   27.5°  | 32.5°

═══════════════════════════════════════════════════════════════════
              为什么静态MUSIC会失败？                              
═══════════════════════════════════════════════════════════════════
【静态MUSIC分析】
  特征值: [3.23, 0.0130, 0.0120, 0.0077]
  估计角度: 106.0°（真实: 60.0°）
  误差: 46.0°

【失败原因】
  运动阵列第k个快拍的信号: x(k) = s(k) * a(θ, pos(t_k))
  每个快拍的导向矢量 a(θ, pos(t_k)) 都不同！
  用t=0的位置 pos(0) 来构建协方差矩阵，导向矢量不匹配！

  第1个快拍相位: [0.0°, 180.0°, 0.0°, ...]
  第K个快拍相位: [0.0°, 180.0°, 0.0°, ...]
  相位差: 0.0°/阵元 → 相当于不同的入射角！

═══════════════════════════════════════════════════════════════════
                            结论                                   
═══════════════════════════════════════════════════════════════════
【时间平滑MUSIC的本质】
  1. 全虚拟阵列（4阵元×32快拍=128虚拟阵元）只有1个等效快拍
  2. 协方差矩阵秩=1，不能直接用MUSIC
  3. 时间平滑通过子阵列重叠来恢复秩
  4. 但分辨率取决于子阵列孔径，不是全虚拟孔径！

【孔径-秩折中】
  - 子阵列快拍数L越大 → 子阵列孔径越大 → 分辨率越高
  - 子阵列快拍数L越大 → 子阵列数越少 → 协方差估计越不稳定

【最优选择】
  最优子阵列快拍数: L = 12
  对应子阵列孔径: 10.4λ
  有效秩: 21
  估计误差: 27.0°

【如何获得更大孔径？】
  方法1: 增加总快拍数K → 可以同时增大子阵列孔径和秩
  方法2: 增加观测时间 → 同上
  方法3: 使用更复杂的算法（STAP等）

测试完成！
debug_time_smoothing_simple
═══════════════════════════════════════════════════════════════════
                    最简单的时间平滑MUSIC测试                      
═══════════════════════════════════════════════════════════════════
【参数】
  波长: 10.00 cm, 阵元: 4, 间距: 0.5λ
  快拍: 16, 运动: 2.50 m = 25.0λ
  每快拍移动: 0.1667 m = 1.67λ

═══════════════════════════════════════════════════════════════════
测试1: 纯相干信号 (s(k)=1, 即完全相干)
═══════════════════════════════════════════════════════════════════
信号检查:
  X(:,1) 相位: [0.0°, 180.0°, -0.0°, -180.0°, ]
  X(:,K) 相位: [0.0°, 180.0°, 0.0°, 180.0°, ]

子阵列参数: L=4, 子阵列大小=16, 子阵列数=13
子阵列位置 (x坐标, 单位λ):
  0.00 0.50 1.00 1.50 1.67 2.17 2.67 3.17 ...

第1个子阵列信号相位:
  0.0° -180.0° 0.0° 180.0° 120.0° -60.0° 120.0° -60.0° ...

特征值(前5): 15.9651 0.0045 0.0021 0.0019 0.0017 
有效秩: 13
估计角度: 75.5° (真实: 60.0°), 误差: 15.5°

═══════════════════════════════════════════════════════════════════
测试2: AR(1)信号 (ρ=0.95)
═══════════════════════════════════════════════════════════════════
特征值(前5): 18.7083 0.5708 0.1710 0.0720 0.0025 
有效秩: 13
估计角度: 95.5° (真实: 60.0°), 误差: 35.5°

═══════════════════════════════════════════════════════════════════
测试3: 导向矢量验证
═══════════════════════════════════════════════════════════════════
导向矢量与信号的相关性: 1.000000 (应该接近1)

═══════════════════════════════════════════════════════════════════
测试4: 波束形成验证 (不依赖秩)
═══════════════════════════════════════════════════════════════════
波束形成估计: 60.0° (真实: 60.0°), 误差: 0.0°

测试完成！
debug_time_smoothing_correct
═══════════════════════════════════════════════════════════════════
           时间平滑MUSIC - 移动步长对算法的影响                    
═══════════════════════════════════════════════════════════════════

步长(×d) | 步长(λ) | MUSIC误差 | 波束形成误差 | 说明
---------|---------|-----------|--------------|-----------------------------
  0.50   |  0.25   |    19.5°  |      0.0°    | 非整数倍, 破坏平移不变性
  1.00   |  0.50   |    89.0°  |      0.0°    | 整数倍, 满足平移不变性
  1.50   |  0.75   |    76.5°  |      0.0°    | 非整数倍, 破坏平移不变性
  2.00   |  1.00   |    10.0°  |      0.0°    | 整数倍, 满足平移不变性
  1.67   |  0.83   |    30.5°  |      0.0°    | 非整数倍, 破坏平移不变性

═══════════════════════════════════════════════════════════════════
              问题分析：平移不变性                                 
═══════════════════════════════════════════════════════════════════

【空间平滑的平移不变性】
  传统空间平滑中，子阵列1和子阵列2的位置关系：
    子阵列1: [0, d, 2d, ..., (L-1)d]
    子阵列2: [d, 2d, 3d, ..., Ld]
  子阵列2 = 子阵列1 整体平移 d
  导向矢量关系：a_2 = a_1 × exp(-j×φ)，其中φ是全局相位

【时间平滑的平移不变性条件】
  设每快拍移动步长为 Δ，阵元间距为 d
  子阵列1的位置：[0, d, ..., (N-1)d, Δ, Δ+d, ..., Δ+(N-1)d, ...]
  子阵列2的位置：[Δ, Δ+d, ..., (N-1)d+Δ, 2Δ, 2Δ+d, ...]

  要满足平移不变性，需要 Δ = m×d (整数倍)
  这样子阵列2的位置 = 子阵列1的位置 + Δ（整体平移）

【当 Δ ≠ m×d 时】
  子阵列的虚拟阵列结构不再均匀
  例如 Δ = 1.67×d：
    子阵列1: [0, 0.5d, d, 1.5d, 1.67d, 2.17d, ...]
    间距不均匀：0.5d, 0.5d, 0.5d, 0.17d, 0.5d, ...
  MUSIC算法假设的平移不变性被破坏！

═══════════════════════════════════════════════════════════════════
            解决方案：选择合适的步长或使用其他方法                  
═══════════════════════════════════════════════════════════════════

【方案1】选择步长为阵元间距的整数倍
  - 步长 = d 时，时间平滑等效于空间平滑
  - 但实际运动速度可能无法精确控制

【方案2】使用波束形成代替MUSIC
  - 波束形成不依赖平移不变性假设
  - 可以处理任意运动轨迹
  - 但分辨率不如MUSIC

【方案3】修改时间平滑的导向矢量构建方式
  - 不使用固定的子阵列位置
  - 每个子阵列使用自己的实际位置
  - 这需要更复杂的算法实现

测试完成！
debug_time_smoothing_correct
═══════════════════════════════════════════════════════════════════
           时间平滑MUSIC - 移动步长对算法的影响                    
═══════════════════════════════════════════════════════════════════

步长(×d) | 步长(λ) | MUSIC误差 | 波束形成误差 | 说明
---------|---------|-----------|--------------|-----------------------------
  0.50   |  0.25   |    69.0°  |      0.0°    | 非整数倍, 破坏平移不变性
  1.00   |  0.50   |    48.5°  |      0.0°    | 整数倍, 满足平移不变性
  1.50   |  0.75   |    21.5°  |      0.0°    | 非整数倍, 破坏平移不变性
  2.00   |  1.00   |    88.5°  |      0.0°    | 整数倍, 满足平移不变性
  1.67   |  0.83   |    38.5°  |      0.0°    | 非整数倍, 破坏平移不变性

═══════════════════════════════════════════════════════════════════
              问题分析：平移不变性                                 
═══════════════════════════════════════════════════════════════════

【空间平滑的平移不变性】
  传统空间平滑中，子阵列1和子阵列2的位置关系：
    子阵列1: [0, d, 2d, ..., (L-1)d]
    子阵列2: [d, 2d, 3d, ..., Ld]
  子阵列2 = 子阵列1 整体平移 d
  导向矢量关系：a_2 = a_1 × exp(-j×φ)，其中φ是全局相位

【时间平滑的平移不变性条件】
  设每快拍移动步长为 Δ，阵元间距为 d
  子阵列1的位置：[0, d, ..., (N-1)d, Δ, Δ+d, ..., Δ+(N-1)d, ...]
  子阵列2的位置：[Δ, Δ+d, ..., (N-1)d+Δ, 2Δ, 2Δ+d, ...]

  要满足平移不变性，需要 Δ = m×d (整数倍)
  这样子阵列2的位置 = 子阵列1的位置 + Δ（整体平移）

【当 Δ ≠ m×d 时】
  子阵列的虚拟阵列结构不再均匀
  例如 Δ = 1.67×d：
    子阵列1: [0, 0.5d, d, 1.5d, 1.67d, 2.17d, ...]
    间距不均匀：0.5d, 0.5d, 0.5d, 0.17d, 0.5d, ...
  MUSIC算法假设的平移不变性被破坏！

═══════════════════════════════════════════════════════════════════
            解决方案：选择合适的步长或使用其他方法                  
═══════════════════════════════════════════════════════════════════

【方案1】选择步长为阵元间距的整数倍
  - 步长 = d 时，时间平滑等效于空间平滑
  - 但实际运动速度可能无法精确控制

【方案2】使用波束形成代替MUSIC
  - 波束形成不依赖平移不变性假设
  - 可以处理任意运动轨迹
  - 但分辨率不如MUSIC

【方案3】修改时间平滑的导向矢量构建方式
  - 不使用固定的子阵列位置
  - 每个子阵列使用自己的实际位置
  - 这需要更复杂的算法实现

测试完成！
debug_time_smoothing_rank
═══════════════════════════════════════════════════════════════════
       时间平滑MUSIC的核心问题：协方差矩阵的秩                     
═══════════════════════════════════════════════════════════════════

【子阵列信号分析】

子阵列之间的相关性：
  子阵列1 vs 子阵列2: 相关系数=1.000000, 相位差=180.0°
  子阵列1 vs 子阵列3: 相关系数=1.000000, 相位差=0.0°
  子阵列1 vs 子阵列4: 相关系数=1.000000, 相位差=180.0°

⚠ 关键发现：所有子阵列的相关系数 = 1.0！
  子阵列之间只有全局相位差，没有"解相干"！

【协方差矩阵秩分析】

无噪声协方差矩阵：
  特征值(前5): 16.0000 0.0000 0.0000 0.0000 0.0000 
  秩 = 1

有噪声协方差矩阵 (SNR=40dB)：
  特征值(前5): 15.9974 0.0005 0.0003 0.0003 0.0002 
  数值秩 = 12（但真实信号秩仍为1！）

═══════════════════════════════════════════════════════════════════
                        数学证明                                   
═══════════════════════════════════════════════════════════════════

【为什么时间平滑对相干信号无效？】

设子阵列i的信号为 x_i，子阵列1的信号为 x_1。
对于匀速直线运动，x_i 和 x_1 的关系：

  x_i = x_1 × exp(-j×φ_i)  （全局相位因子）

其中 φ_i = 4π/λ × (i-1)×Δ × cos(θ)，Δ是每快拍移动距离。

协方差矩阵：
  R_i = x_i × x_i^H
      = x_1 × exp(-j×φ_i) × (x_1 × exp(-j×φ_i))^H
      = x_1 × exp(-j×φ_i) × exp(+j×φ_i) × x_1^H
      = x_1 × x_1^H  （全局相位消掉了！）

平滑后：
  R_smoothed = Σ R_i / M = x_1 × x_1^H  （秩=1！）

⚠ 结论：对于相干信号，时间平滑不能增加秩！
  MUSIC需要 秩 > 目标数，所以MUSIC失败。

═══════════════════════════════════════════════════════════════════
                传统空间平滑 vs 时间平滑                           
═══════════════════════════════════════════════════════════════════

【传统空间平滑】（解相干多目标）
  - 多个相干目标同时存在
  - 目标信号 s_1, s_2, ... 完全相干（如反射路径）
  - 空间平滑通过子阵列重叠打破相干性
  - 关键：不同子阵列看到的目标相位不同
  - 结果：协方差矩阵秩增加，MUSIC可用

【时间平滑】（合成孔径）
  - 单目标，阵列移动
  - 目标信号 s(t) 可能是相干的
  - 如果 s(t)=常数（完全相干）：
    → 不同子阵列的信号只有全局相位差
    → 协方差矩阵秩=1，MUSIC无法使用
  - 如果 s(t) 有变化（如AR模型、闪烁）：
    → 可以增加有效秩
    → 但需要足够低的相关系数

═══════════════════════════════════════════════════════════════════
                      解决方案                                     
═══════════════════════════════════════════════════════════════════

【方案1：全虚拟阵列波束形成】
  原理：匹配滤波器，不依赖协方差矩阵秩
  公式：P(θ) = |a(θ)^H × x|²
  结果：估计=60.0°, 误差=0.0°
  ✓ 适用于相干信号，可处理任意轨迹

【方案2：使用低相关系数信号模型】
  测试不同相关系数的AR(1)模型：
    ρ=0.99: MUSIC误差=16.5°, 特征值比=193.8
    ρ=0.90: MUSIC误差=14.5°, 特征值比=7.8
    ρ=0.70: MUSIC误差=44.5°, 特征值比=4.7
    ρ=0.50: MUSIC误差=39.5°, 特征值比=1.3
    ρ=0.30: MUSIC误差=14.5°, 特征值比=1.4

  → 相关系数越低，MUSIC性能越好
  → 但实际FMCW雷达中，静态目标的信号高度相干

═══════════════════════════════════════════════════════════════════
                         结论                                      
═══════════════════════════════════════════════════════════════════

1. 时间平滑MUSIC对相干信号（s=常数）无效
   → 协方差矩阵秩=1，不满足MUSIC的秩条件

2. 波束形成是正确的选择
   → 不依赖秩条件，可处理任意相干信号
   → 利用全部合成孔径

3. 如果要用MUSIC，信号必须有足够的解相干
   → AR(1)模型，相关系数 < 0.7
   → 目标RCS闪烁等

测试完成！
verify_original_works
═══════════════════════════════════════════════════════════════════
               验证原始时间平滑MUSIC是否工作                       
═══════════════════════════════════════════════════════════════════

【参数】
  波长: 9.99 cm
  快拍数: 64
  运动速度: 5.0 m/s
  运动距离: 2.50 m = 25.0λ
  目标: φ=30.0°, θ=75.0°

{未识别类 'ArrayPlatform' 的方法、属性或字段 'set_elements'。

出错 <a href="matlab:matlab.lang.internal.introspective.errorDocCallback('verify_original_works', 'E:\code\matlab\rader_mimo\scripts\verify_original_works.m', 51)" style="font-weight:bold">verify_original_works</a> (<a href="matlab: opentoline('E:\code\matlab\rader_mimo\scripts\verify_original_works.m',51,0)">第 51 行</a>)
array.set_elements(element_positions, element_positions, 1, 1:num_elements);
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
} 
verify_original_works
═══════════════════════════════════════════════════════════════════
               验证原始时间平滑MUSIC是否工作                       
═══════════════════════════════════════════════════════════════════

【参数】
  波长: 9.99 cm
  快拍数: 64
  运动速度: 5.0 m/s
  运动距离: 2.50 m = 25.0λ
  目标: φ=30.0°, θ=75.0°

{未识别类 'ArrayPlatform' 的方法、属性或字段 'set_elements'。

出错 <a href="matlab:matlab.lang.internal.introspective.errorDocCallback('verify_original_works', 'E:\code\matlab\rader_mimo\scripts\verify_original_works.m', 51)" style="font-weight:bold">verify_original_works</a> (<a href="matlab: opentoline('E:\code\matlab\rader_mimo\scripts\verify_original_works.m',51,0)">第 51 行</a>)
array.set_elements(element_positions, element_positions, 1, 1:num_elements);
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
} 
verify_original_works
═══════════════════════════════════════════════════════════════════
               验证原始时间平滑MUSIC是否工作                       
═══════════════════════════════════════════════════════════════════

【参数】
  波长: 9.99 cm
  快拍数: 64
  运动速度: 5.0 m/s
  运动距离: 2.50 m = 25.0λ
  目标: φ=30.0°, θ=75.0°

【信号生成】
  信号生成完成
  信号大小: 8 × 64

【静态MUSIC（忽略运动）】
  特征值(前5): 3.92 0.01 0.01 0.01 0.01 
  估计: φ=82.5°, θ=71.5°
  误差: φ=52.5°, θ=3.5°

【DoaEstimatorSynthetic（时间平滑MUSIC）】
  估计: φ=30.5°, θ=76.0°
  误差: φ=0.5°, θ=1.0°

测试完成！
complex_trajectory_test
